1149
1149번 문제는 DP를 사용하여 풀었다.

1149문제에서 N번째 집을 색칠하기 위해서 고려해야할 사항은 N-1번째의 집의 색깔이다.

만약 N번째 집을 빨강으로 칠한다면 N-1번째 집의 색은 초록, 파랑 중 하나일것이다.

또한 N번째 집을 초록으로 칠한다면 N-1번째 집의 색은 빨강, 파랑 중 하나일것이다.

이 때, 비용의 최소값을 구해야하기 때문에 N-1번째 집의 최소비용에서 N번째 집의 비용을 더하면 1부터 N번째 집의 색을

칠했을때 가장 최소값이 나올 것 이다.

N번째 집에는 무슨 색이 올 지 모르기 때문에 int 3개의 칸을 지정해놓고 그 칸에다가 N-1번째 집이 빨강, 초록, 파랑으로 결정됬을때의

최소비용을 저장해놓고 N번째 집을 빨강색으로 칠할때 N-1번째의 초록, 파랑 중 최소값을 가져와서 빨강색으로 칠하는 값을 더하여

다시 배열에 저장해놓는다.

그렇게 N번째 까지 도달하면 그 중 최소값을 찾는다.

1520
1520문제는 솔직히 사이트 참조를 하였다.
https://wootool.tistory.com/83
https://sihyungyou.github.io/baekjoon-1520/

1주차 문제와 똑같은 유형이었는데, dfs + dp를 사용하는 방식이다.

1주차 문제는 많아 봤자 100개의 칸을 dfs사용하여 푸는 방식이었음에도 불구하고 탐색 불가능 할 정도로 시간이 오래 걸렸는데

이번 문제는 500 * 500의 칸을 최대로 하기 때문에 처음부터 dfs를 시도해보지는 않았다.

그래서 인터넷 검색을 하던 중 dp 메모이제이션이라는 방식을 찾았다.

dfs같은 재귀함수의 가장 큰 문제는 중복 연산이다. 피보나치 수열을 예를 들 수 있다.

피보나치 수열의 점화식은 f(n) = f(n-1) + f(n-2)이다.

f(4)를 계산하기 위해선

f(4) = f(2) + f(1) + f(1) + f(0)

-> f(4) = f(1) + f(0) + f(1) + f(1) + f(0)이 될 것이다.

이때 f(2)를 구하려면 f(1) f(0)으로 들어가야하는 번거로움이 있는데

f(2)의 값을 -1로 초기화된 배열에다가 저장시키고 만약 n번째 배열의 안에 -1이 아니면 그 값은

이미 구해져 있는 값이 된다. 즉 f(2)의 값이 f(1) + f(0)이면 그 값을 배열 안에 저장해놓고

f(2)를 사용할 때, f(2) -> f(1) + f(0)의 과정을 거치지 않고 바로 f_a(2)의 값을 사용 한다는 뜻이다.

이를 1520에 적용해 본다면, 갈 수 있는 방향이 있다면 그 방향으로 dfs를 실행하고, 결과적으로 N,M에 도착하면 1을 return한다.

1을 return했다는 뜻은 dfs하면서 거친 길이 모두 n,m과 이어지는 길이라는 뜻이기 때문에 그 길에는 갈 수 있는 방법이 1가지 존재하는

것이기 때문에 1을 dp값에 채워넣는다.

그 후 갈림길이 나온다면, 갈림길에서 또 다시 dfs를 실시하고 만약 초기화 한 값 -1이 아닌 다른 값이 나오고, 그 길과 이어질 수 있다면 

이 또한 이때까지 dfs를 거친길이 n,m과 이어 질 수 있다는 뜻이다. 그렇다면 이 갈림길에 기존에 존재하던 값에 dfs한 길이 추가

되는 것 이니까 이 갈림길에는 dfs해서 얻은 결과값과 기존에 존재하던 dp의 값을 더한다. 그렇다면 만약 이 갈림길에 도착 했을때,

n,m까지 갈 수 있는 경우의 수가 나오게 된다.

이를 계속 반복하다보면 dp의 시작 부분에 n,m까지 갈 수 있는 모든 경우의 수가 채워진다.